import { _ as _export_sfc, j as openBlock, k as createElementBlock, l as createBaseVNode, d as defineComponent, m as createVNode, q as withCtx, F as withDirectives, G as vShow, T as Transition, H as normalizeClass, I as renderSlot, v as pushScopeId, x as popScopeId, r as ref, J as toRef, c as computed, K as readonly, L as reactive, o as onMounted, B as watch, M as onUnmounted, N as Fragment, O as renderList, P as unref, Q as createCommentVNode, t as toDisplayString, R as withModifiers, s as createTextVNode, S as createBlock, U as toRaw } from "./entry.e4388931.js";
const _sfc_main$4 = {};
const _hoisted_1$4 = {
  t: "1678102103095",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "4727",
  width: "200",
  height: "200"
};
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M881 177l-104 104L830 334c18.8 18.8 18.8 49.2 0 67.8l-34.8 34.8c23.6 52.2 36.8 110.2 36.8 171.2 0 229.8-186.2 416-416 416S0 837.8 0 608 186.2 192 416 192c61 0 119 13.2 171.2 36.8L622 194c18.8-18.8 49.2-18.8 67.8 0l53 53 104-104 34.2 34zM1000 120h-48c-13.2 0-24 10.8-24 24s10.8 24 24 24h48c13.2 0 24-10.8 24-24s-10.8-24-24-24zM880 0c-13.2 0-24 10.8-24 24v48c0 13.2 10.8 24 24 24s24-10.8 24-24V24c0-13.2-10.8-24-24-24z m67.8 110l34-34c9.4-9.4 9.4-24.6 0-34-9.4-9.4-24.6-9.4-34 0l-34 34c-9.4 9.4-9.4 24.6 0 34 9.6 9.4 24.8 9.4 34 0z m-135.6 0c9.4 9.4 24.6 9.4 34 0 9.4-9.4 9.4-24.6 0-34l-34-34c-9.4-9.4-24.6-9.4-34 0-9.4 9.4-9.4 24.6 0 34l34 34z m135.6 68c-9.4-9.4-24.6-9.4-34 0-9.4 9.4-9.4 24.6 0 34l34 34c9.4 9.4 24.6 9.4 34 0 9.4-9.4 9.4-24.6 0-34l-34-34zM224 544c0-70.6 57.4-128 128-128 17.6 0 32-14.4 32-32s-14.4-32-32-32c-105.8 0-192 86.2-192 192 0 17.6 14.4 32 32 32s32-14.4 32-32z",
  "p-id": "4728",
  fill: "currentColor"
}, null, -1);
const _hoisted_3$4 = [
  _hoisted_2$4
];
function _sfc_render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_3$4);
}
const __nuxt_component_0 = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$2]]);
const _sfc_main$3 = {};
const _hoisted_1$3 = {
  t: "1678103260931",
  class: "icon",
  viewBox: "0 0 1025 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "5705",
  width: "200",
  height: "200"
};
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M182.857143 146.285714q0 41.179429-36.571429 62.829714l0 723.456q0 7.460571-5.412571 12.873143t-12.873143 5.412571l-36.571429 0q-7.460571 0-12.873143-5.412571t-5.412571-12.873143l0-723.456q-36.571429-21.723429-36.571429-62.829714 0-30.281143 21.430857-51.712t51.712-21.430857 51.712 21.430857 21.430857 51.712zM1024 182.857143l0 436.004571q0 14.262857-7.168 22.016t-22.601143 15.725714q-122.88 66.267429-210.870857 66.267429-34.889143 0-70.582857-12.580571t-62.025143-27.428571-65.974857-27.428571-81.408-12.580571q-109.714286 0-265.142857 83.456-9.728 5.12-18.870857 5.12-14.848 0-25.746286-10.825143t-10.825143-25.746286l0-424.009143q0-18.285714 17.700571-31.451429 11.995429-7.972571 45.129143-24.576 134.875429-68.534857 240.566857-68.534857 61.147429 0 114.322286 16.603429t125.147429 50.322286q21.723429 10.825143 50.322286 10.825143 30.866286 0 67.145143-11.995429t62.829714-26.843429 50.322286-26.843429 31.158857-11.995429q14.848 0 25.746286 10.825143t10.825143 25.746286z",
  fill: "currentColor",
  "p-id": "5706"
}, null, -1);
const _hoisted_3$3 = [
  _hoisted_2$3
];
function _sfc_render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_3$3);
}
const __nuxt_component_1 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$1]]);
const _sfc_main$2 = {};
const _hoisted_1$2 = {
  t: "1678254072982",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "2122",
  width: "200",
  height: "200"
};
const _hoisted_2$2 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M512 1023.998046A511.999023 511.999023 0 0 1 312.610948 41.080156a511.999023 511.999023 0 0 1 398.778104 942.839689 508.993158 508.993158 0 0 1-199.389052 40.078201z m0-943.841643C273.534702 80.156403 80.15738 274.53568 80.15738 511.999023s193.377322 431.84262 431.84262 431.84262 431.84262-193.377322 431.84262-431.84262S749.463343 80.156403 512 80.156403z",
  fill: "currentColor",
  "p-id": "2123"
}, null, -1);
const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M320.626588 743.450636a40.078201 40.078201 0 0 1-28.054741-68.132942l381.744869-381.744869a40.383798 40.383798 0 0 1 57.111437 57.111437L349.683284 731.427176a40.078201 40.078201 0 0 1-29.056696 12.02346z",
  fill: "currentColor",
  "p-id": "2124"
}, null, -1);
const _hoisted_4$2 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M702.371457 743.450636a40.078201 40.078201 0 0 1-28.054741-12.02346L292.571847 349.682307a40.383798 40.383798 0 0 1 57.111437-57.111437l380.742914 382.746824a40.078201 40.078201 0 0 1-28.054741 68.132942z",
  fill: "currentColor",
  "p-id": "2125"
}, null, -1);
const _hoisted_5$2 = [
  _hoisted_2$2,
  _hoisted_3$2,
  _hoisted_4$2
];
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_5$2);
}
const __nuxt_component_2 = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render]]);
const _withScopeId = (n) => (pushScopeId("data-v-b97c1c45"), n = n(), popScopeId(), n);
const _hoisted_1$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "mw-ck-box-block" }, null, -1));
const _hoisted_2$1 = {
  class: "ck-icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("path", {
  d: "M369.792 704.32L930.304 128 1024 223.616 369.984 896l-20.288-20.864-0.128 0.128L0 516.8 96.128 423.68l273.664 280.64z",
  fill: "currentColor"
}, null, -1));
const _hoisted_4$1 = [
  _hoisted_3$1
];
const _hoisted_5$1 = { class: "ck-label" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "checkbox",
  props: {
    modelValue: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const handleCheck = () => {
      if (props.disabled) {
        return;
      }
      emits("update:modelValue", !props.modelValue);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "ck-wrapper",
        onClick: handleCheck
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["ck-box-wrapper", {
            "mw-ck-box--checked": props.modelValue,
            "mw-ck-box--disabled": props.disabled
          }])
        }, [
          _hoisted_1$1,
          createVNode(Transition, { name: "check" }, {
            default: withCtx(() => [
              withDirectives((openBlock(), createElementBlock("svg", _hoisted_2$1, _hoisted_4$1, 512)), [
                [vShow, props.modelValue]
              ])
            ]),
            _: 1
          })
        ], 2),
        createBaseVNode("span", _hoisted_5$1, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]);
    };
  }
});
const checkbox_vue_vue_type_style_index_0_scoped_b97c1c45_lang = "";
const __nuxt_component_3 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-b97c1c45"]]);
function useTimer(config = {}) {
  const { fps = 0, immediate = false } = config;
  const time = ref(0);
  const isStarted = ref(false);
  let frameId = 0;
  let beginTime = 0;
  let lastUpdate = 0;
  let lastTimeElapsed = 0;
  const computedFps = toRef(fps);
  const interval = computed(() => computedFps.value <= 0 ? 0 : 1e3 / computedFps.value);
  const updateTime = () => {
    const now = performance.now();
    time.value = now - beginTime;
    lastUpdate = now;
  };
  const tick = () => {
    const now = performance.now();
    if (now - lastUpdate > interval.value) {
      updateTime();
    }
    if (isStarted.value) {
      frameId = requestAnimationFrame(tick);
    }
  };
  const start = () => {
    if (isStarted.value) {
      return;
    }
    beginTime = performance.now() - lastTimeElapsed;
    isStarted.value = true;
    frameId = requestAnimationFrame(tick);
    updateTime();
  };
  const stop = () => {
    if (!isStarted.value) {
      return;
    }
    cancelAnimationFrame(frameId);
    lastTimeElapsed = performance.now() - beginTime;
    isStarted.value = false;
    updateTime();
  };
  const reset = () => {
    const now = performance.now();
    beginTime = now;
    lastUpdate = now;
    lastTimeElapsed = 0;
    time.value = 0;
  };
  if (immediate) {
    start();
  }
  return {
    time: readonly(time),
    isStarted: readonly(isStarted),
    start,
    stop,
    reset
  };
}
const _hoisted_1 = ["onMousedown", "onMouseup", "onMouseenter"];
const _hoisted_2 = {
  key: "showing",
  id: "lock-mask"
};
const _hoisted_3 = {
  key: 0,
  id: "initializing-mask"
};
const _hoisted_4 = { id: "operations" };
const _hoisted_5 = { class: "game-params" };
const _hoisted_6 = { class: "cheat-hint" };
const _hoisted_7 = { class: "btn-group" };
const MINE_NUMBER = 100;
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "minesweeper",
  setup(__props) {
    const config = reactive({
      avoidBadStart: true,
      enableProp: false
    });
    onMounted(() => {
      const configStr = localStorage.getItem("config");
      if (configStr) {
        try {
          const configObj = JSON.parse(configStr);
          if (!configObj) {
            return;
          }
          if (typeof configObj.avoidBadStart !== "undefined" && typeof configObj.avoidBadStart === "boolean") {
            config.avoidBadStart = configObj.avoidBadStart;
          }
          if (typeof configObj.enableProp !== "undefined" && typeof configObj.enableProp === "boolean") {
            config.enableProp = configObj.enableProp;
          }
        } catch {
        }
      }
    });
    watch(config, (val) => {
      localStorage.setItem("config", JSON.stringify(toRaw(val)));
    });
    const gameMap = ref([]);
    const gameStatus = ref(
      1
      /* PRE_GAME */
    );
    const isReproducedGame = ref(false);
    const formatTime = (time2) => {
      const h = (Math.floor(time2 / 36e5) % 60).toString().padStart(2, "0");
      const m = (Math.floor(time2 / 6e4) % 60).toString().padStart(2, "0");
      const s = (Math.floor(time2 / 1e3) % 60).toString().padStart(2, "0");
      const ss = (Math.floor(time2) % 1e3).toString().padStart(3, "0");
      return `${h}:${m}:${s}:${ss}`;
    };
    const {
      time,
      reset: resetTimer,
      start: startTimer,
      stop: stopTimer
    } = useTimer({
      fps: 15,
      immediate: false
    });
    const formattedTime = computed(() => {
      return formatTime(time.value);
    });
    const randomInt = (min, max) => {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };
    const randomIntX = (min, max, power) => {
      const diff = max - min;
      const rand = Math.random() ** power;
      return Math.floor(rand * diff) + min;
    };
    const getCellsAround = (row, col) => {
      const aroundCells = [];
      if (row - 1 >= 0) {
        aroundCells.push({
          row: row - 1,
          col,
          cell: gameMap.value[row - 1][col]
        });
      }
      if (col - 1 >= 0) {
        aroundCells.push({
          row,
          col: col - 1,
          cell: gameMap.value[row][col - 1]
        });
      }
      if (row + 1 < gameMap.value.length) {
        aroundCells.push({
          row: row + 1,
          col,
          cell: gameMap.value[row + 1][col]
        });
      }
      if (col + 1 < gameMap.value[0].length) {
        aroundCells.push({
          row,
          col: col + 1,
          cell: gameMap.value[row][col + 1]
        });
      }
      if (row - 1 >= 0 && col - 1 >= 0) {
        aroundCells.push({
          row: row - 1,
          col: col - 1,
          cell: gameMap.value[row - 1][col - 1]
        });
      }
      if (row - 1 >= 0 && col + 1 < gameMap.value[0].length) {
        aroundCells.push({
          row: row - 1,
          col: col + 1,
          cell: gameMap.value[row - 1][col + 1]
        });
      }
      if (row + 1 < gameMap.value.length && col - 1 >= 0) {
        aroundCells.push({
          row: row + 1,
          col: col - 1,
          cell: gameMap.value[row + 1][col - 1]
        });
      }
      if (row + 1 < gameMap.value.length && col + 1 < gameMap.value[0].length) {
        aroundCells.push({
          row: row + 1,
          col: col + 1,
          cell: gameMap.value[row + 1][col + 1]
        });
      }
      return aroundCells;
    };
    const generateMap = (rowCount, colCount, mineCount) => {
      if (mineCount === 0) {
        mineCount = 1;
      }
      if (rowCount * colCount === mineCount) {
        rowCount++;
      }
      gameParams.rows = rowCount;
      gameParams.cols = colCount;
      gameParams.mineCount = mineCount;
      const newGameMap = [];
      for (let i = 0; i < rowCount; i++) {
        const row = [];
        for (let j = 0; j < colCount; j++) {
          row.push({
            id: i * rowCount + j,
            mineCount: 0,
            cellProp: 0,
            revealed: false,
            flagged: false,
            showInfluence: false,
            wrongFlag: false,
            canFlag: false,
            toReveal: false
          });
        }
        newGameMap.push(row);
      }
      const candidatesArr = [];
      for (let i = 0; i < rowCount; i++) {
        for (let j = 0; j < colCount; j++) {
          candidatesArr.push({ row: i, col: j });
        }
      }
      let minePlaced = 0;
      while (minePlaced < mineCount) {
        const index = randomInt(0, candidatesArr.length - 1);
        const pos = candidatesArr[index];
        candidatesArr.splice(index, 1);
        newGameMap[pos.row][pos.col].mineCount = MINE_NUMBER;
        minePlaced++;
      }
      gameMap.value = newGameMap;
      for (let i = 0; i < rowCount; i++) {
        for (let j = 0; j < colCount; j++) {
          if (newGameMap[i][j].mineCount === MINE_NUMBER) {
            continue;
          }
          const cell = gameMap.value[i][j];
          const mineCountAround = getCellsAround(i, j).reduce((p, c) => {
            return p + (c.cell.mineCount === MINE_NUMBER ? 1 : 0);
          }, 0);
          cell.mineCount = mineCountAround;
        }
      }
    };
    const revealCellAndCheckWin = (row, col, isArea = false) => {
      if (gameStatus.value !== 2 || row < 0 || row >= gameMap.value.length || col < 0 || col >= gameMap.value[0].length) {
        return;
      }
      const cell = gameMap.value[row][col];
      if (cell.revealed || cell.flagged) {
        return;
      }
      if (cell.mineCount === MINE_NUMBER) {
        gameStatus.value = 4;
        stopTimer();
        revealAll();
      } else if (cell.mineCount === 0) {
        revealArea(row, col);
      } else {
        cell.revealed = true;
      }
      checkGameEndAndCleanup();
    };
    const checkGameEndAndCleanup = () => {
      if (gameStatus.value === 2 && checkWin()) {
        gameStatus.value = 8;
        revealAll(true);
        stopTimer();
      }
    };
    const flaggedCount = ref(0);
    const flag = (row, col) => {
      if (gameStatus.value !== 2) {
        return;
      }
      const cell = gameMap.value[row][col];
      if (!cell.revealed) {
        cell.flagged = !cell.flagged;
        if (cell.flagged) {
          flaggedCount.value++;
        } else {
          flaggedCount.value--;
        }
      }
    };
    const revealArea = (row, col) => {
      if (row < 0 || row >= gameMap.value.length || col < 0 || col >= gameMap.value[0].length) {
        return;
      }
      const cell = gameMap.value[row][col];
      if (cell.revealed || cell.flagged) {
        return;
      }
      cell.revealed = true;
      if (cell.mineCount === 0) {
        getCellsAround(row, col).forEach((c) => revealArea(c.row, c.col));
      }
    };
    const relocateMineOnFirstClick = (row, col) => {
      const cell = gameMap.value[row][col];
      if (cell.mineCount === MINE_NUMBER) {
        let newRow;
        let newCol;
        let loopCount = 0;
        while (true) {
          if (loopCount > 15) {
            for (let i = 0; i < gameMap.value.length; i++) {
              for (let j = 0; j < gameMap.value[0].length; j++) {
                if (gameMap.value[i][j].mineCount !== MINE_NUMBER) {
                  newRow = i;
                  newCol = j;
                  break;
                }
              }
            }
            newRow = 0;
            newCol = 0;
          } else {
            const r = randomInt(0, gameMap.value.length - 1);
            const c = randomInt(0, gameMap.value[0].length - 1);
            if (gameMap.value[r][c].mineCount !== MINE_NUMBER) {
              newRow = r;
              newCol = c;
              break;
            }
          }
          loopCount++;
        }
        let temp = gameMap.value[row][col];
        gameMap.value[row][col] = gameMap.value[newRow][newCol];
        gameMap.value[newRow][newCol] = temp;
        const affectedCells = /* @__PURE__ */ new Set();
        affectedCells.add({
          row,
          col,
          cell: gameMap.value[row][col]
        });
        getCellsAround(row, col).forEach((c) => affectedCells.add(c));
        getCellsAround(newRow, newCol).forEach((c) => affectedCells.add(c));
        affectedCells.forEach((c) => {
          if (c.cell.mineCount === MINE_NUMBER) {
            return;
          }
          const mineCountAround = getCellsAround(c.row, c.col).reduce((p, c2) => {
            return p + (c2.cell.mineCount === MINE_NUMBER ? 1 : 0);
          }, 0);
          c.cell.mineCount = mineCountAround;
        });
      }
    };
    let pressingState;
    let unrevealedCellsAround;
    let currentPos;
    let keydownCallback;
    let keyupCallback;
    let isPressingZ = false;
    const cellInfoText = ref("");
    const handleMouseDown = (e, row, col) => {
      switch (e.buttons) {
        case 1:
          pressingState = 1;
          break;
        case 2:
          pressingState = 2;
          break;
        case 3:
        case 4:
        case 7:
          pressingState = 4;
          showInfluence(row, col);
          break;
      }
    };
    const handleMouseUp = (_, row, col) => {
      switch (pressingState) {
        case 1:
          if (gameStatus.value === 1) {
            gameStatus.value = 2;
            startTimer();
            if (config.avoidBadStart) {
              relocateMineOnFirstClick(row, col);
            }
          }
          revealCellAndCheckWin(row, col);
          break;
        case 2:
          if (gameStatus.value === 1) {
            gameStatus.value = 2;
            startTimer();
          }
          flag(row, col);
          break;
        case 4:
          revealAreaIfFlaggedEnough(row, col);
          clearHighlight();
          pressingState = 0;
          break;
      }
    };
    const updateCellInfoOnHover = (show) => {
      if (!currentPos) {
        return;
      }
      if (!show || !isPressingZ) {
        cellInfoText.value = "";
        return;
      }
      const cell = gameMap.value[currentPos.row][currentPos.col];
      cellInfoText.value = `${cell.mineCount === MINE_NUMBER ? "M" : cell.mineCount}`;
    };
    onMounted(() => {
      document.body.addEventListener(
        "keydown",
        keydownCallback = (e) => {
          if (e.repeat || e.key.toUpperCase() !== "Z") {
            return;
          }
          isPressingZ = true;
          updateCellInfoOnHover(true);
        }
      );
      document.body.addEventListener(
        "keyup",
        keyupCallback = (e) => {
          if (e.key.toUpperCase() !== "Z") {
            return;
          }
          isPressingZ = false;
          updateCellInfoOnHover(false);
        }
      );
    });
    onUnmounted(() => {
      document.body.removeEventListener("keydown", keydownCallback);
      document.body.removeEventListener("keyup", keyupCallback);
    });
    const handleMouseEnter = (_, row, col) => {
      currentPos = { row, col };
      updateCellInfoOnHover(true);
      if (pressingState === 4) {
        clearHighlight();
        showInfluence(row, col);
      }
    };
    const clearHighlight = () => {
      if (unrevealedCellsAround) {
        unrevealedCellsAround.forEach((c) => {
          c.cell.showInfluence = false;
          c.cell.toReveal = false;
          c.cell.canFlag = false;
        });
      }
    };
    const clearCellInfo = () => {
      updateCellInfoOnHover(false);
    };
    const resetInteractionState = () => {
      pressingState = 0;
      currentPos = null;
      clearHighlight();
    };
    const showInfluence = (row, col) => {
      if (gameMap.value[row][col].revealed) {
        const cells = getCellsAround(row, col).filter((c) => !c.cell.revealed);
        const restCells = cells.filter((c) => !c.cell.flagged);
        const flaggedCount2 = cells.reduce((p, c) => p + (c.cell.flagged ? 1 : 0), 0);
        if (flaggedCount2 >= gameMap.value[row][col].mineCount) {
          restCells.forEach((c) => {
            c.cell.toReveal = true;
          });
        } else if (cells.length === gameMap.value[row][col].mineCount) {
          restCells.forEach((c) => {
            c.cell.canFlag = true;
          });
        } else {
          restCells.forEach((c) => {
            c.cell.showInfluence = true;
          });
        }
        unrevealedCellsAround = cells;
      }
    };
    const revealAreaIfFlaggedEnough = (row, col) => {
      const cell = gameMap.value[row][col];
      if (!cell.revealed || cell.mineCount < 1 || cell.mineCount > 8) {
        return;
      }
      const cells = getCellsAround(row, col);
      const flaggedCount2 = unrevealedCellsAround.reduce(
        (p, c) => p + (c.cell.flagged ? 1 : 0),
        0
      );
      if (flaggedCount2 >= gameMap.value[row][col].mineCount) {
        cells.filter((c) => !c.cell.revealed).forEach((c) => revealCellAndCheckWin(c.row, c.col, true));
      }
    };
    const revealAll = (fillFlag = false) => {
      for (let i = 0; i < gameMap.value.length; i++) {
        for (let j = 0; j < gameMap.value[0].length; j++) {
          const cell = gameMap.value[i][j];
          if (!cell.revealed) {
            if (cell.mineCount === MINE_NUMBER && fillFlag) {
              if (!cell.flagged) {
                cell.flagged = true;
                flaggedCount.value++;
              }
            } else if (cell.mineCount !== MINE_NUMBER && cell.flagged) {
              cell.revealed = true;
              cell.wrongFlag = true;
            } else {
              cell.revealed = true;
            }
          }
        }
      }
    };
    const gameParams = reactive({
      rows: 0,
      cols: 0,
      mineCount: 0
    });
    const generateRandomSizeMap = () => {
      const rows = randomIntX(10, 40, 2);
      const cols = randomIntX(10, 60, 2);
      const mineCount = randomInt(
        Math.floor(rows * cols * 0.08),
        Math.floor(rows * cols * 0.2)
      );
      generateMap(rows, cols, mineCount);
    };
    const checkWin = () => {
      let flagged = 0;
      let unrevealedAndNotFlagged = 0;
      let mineCount = 0;
      for (let i = 0; i < gameMap.value.length; i++) {
        for (let j = 0; j < gameMap.value[0].length; j++) {
          const cell = gameMap.value[i][j];
          if (cell.mineCount === MINE_NUMBER) {
            mineCount++;
          }
          if (!cell.revealed && !cell.flagged) {
            unrevealedAndNotFlagged++;
          } else if (cell.flagged) {
            flagged++;
          }
        }
      }
      return flagged + unrevealedAndNotFlagged === mineCount;
    };
    const restartGame = () => {
      gameStatus.value = 1;
      isReproducedGame.value = false;
      flaggedCount.value = 0;
      stopTimer();
      resetTimer();
      generateRandomSizeMap();
    };
    const reproduceGame = () => {
      gameStatus.value = 1;
      isReproducedGame.value = true;
      flaggedCount.value = 0;
      config.avoidBadStart = false;
      stopTimer();
      resetTimer();
      for (let i = 0; i < gameMap.value.length; i++) {
        for (let j = 0; j < gameMap.value[0].length; j++) {
          gameMap.value[i][j] = {
            id: gameMap.value[i][j].id,
            mineCount: gameMap.value[i][j].mineCount,
            cellProp: 0,
            canFlag: false,
            flagged: false,
            revealed: false,
            showInfluence: false,
            toReveal: false,
            wrongFlag: false
          };
        }
      }
    };
    onMounted(() => {
      console.log(
        "Welcome to the Hanxven version of Minesweeper! You can play by pressing either the left, right, or both mouse buttons. Hold 'z' if you wish to cheat. Enjoy the game!"
      );
      generateRandomSizeMap();
    });
    return (_ctx, _cache) => {
      const _component_MinesweeperMine = __nuxt_component_0;
      const _component_MinesweeperFlag = __nuxt_component_1;
      const _component_MinesweeperClose = __nuxt_component_2;
      const _component_MinesweeperCheckbox = __nuxt_component_3;
      return openBlock(), createElementBlock("div", {
        id: "container",
        onContextmenu: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["prevent"])),
        onMouseup: resetInteractionState
      }, [
        createBaseVNode("div", {
          id: "board",
          class: normalizeClass({
            win: unref(gameStatus) === 8,
            lose: unref(gameStatus) === 4,
            initializing: unref(gameMap).length === 0
          }),
          onMouseleave: clearCellInfo
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(gameMap), (row, rowIndex) => {
            return openBlock(), createElementBlock("div", {
              class: "row",
              key: rowIndex
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, colIndex) => {
                return openBlock(), createElementBlock("div", {
                  class: normalizeClass(["cell", {
                    "unrevealed": !cell.revealed,
                    [`cell-${cell.mineCount}`]: cell.revealed,
                    "show-influence": cell.showInfluence,
                    "wrong-flag": cell.wrongFlag,
                    "can-flag": cell.canFlag,
                    "to-reveal": cell.toReveal
                  }]),
                  onMousedown: withModifiers(($event) => handleMouseDown($event, rowIndex, colIndex), ["stop"]),
                  onMouseup: withModifiers(($event) => handleMouseUp($event, rowIndex, colIndex), ["stop"]),
                  onMouseenter: withModifiers(($event) => handleMouseEnter($event, rowIndex, colIndex), ["stop"]),
                  key: cell.id
                }, [
                  cell.revealed ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    cell.mineCount !== 0 && cell.mineCount !== MINE_NUMBER ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(cell.mineCount), 1)
                    ], 64)) : cell.mineCount === MINE_NUMBER ? (openBlock(), createBlock(_component_MinesweeperMine, {
                      key: 1,
                      class: "mine"
                    })) : createCommentVNode("", true)
                  ], 64)) : cell.flagged ? (openBlock(), createBlock(_component_MinesweeperFlag, {
                    key: 1,
                    class: "flag"
                  })) : createCommentVNode("", true),
                  cell.wrongFlag ? (openBlock(), createBlock(_component_MinesweeperClose, {
                    key: 2,
                    class: "wrong-flag-icon"
                  })) : createCommentVNode("", true)
                ], 42, _hoisted_1);
              }), 128))
            ]);
          }), 128)),
          withDirectives(createBaseVNode("div", _hoisted_2, null, 512), [
            [
              vShow,
              unref(gameStatus) !== 2 && unref(gameStatus) !== 1
              /* PRE_GAME */
            ]
          ]),
          unref(gameMap).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_3, "加载中...")) : createCommentVNode("", true)
        ], 34),
        createBaseVNode("div", _hoisted_4, [
          createBaseVNode("div", _hoisted_5, [
            createBaseVNode("span", null, toDisplayString(`时间: ${unref(formattedTime)}`), 1),
            createBaseVNode("span", null, toDisplayString(`${unref(gameParams).rows} x ${unref(gameParams).cols} · ${unref(gameParams).mineCount} 雷`), 1),
            createBaseVNode("span", null, toDisplayString(`(${(unref(gameParams).mineCount / (unref(gameParams).rows * unref(gameParams).cols) * 100).toFixed(2)}% 覆盖率)`), 1),
            createBaseVNode("span", null, toDisplayString(`${unref(flaggedCount)} 已标记`), 1),
            createBaseVNode("span", _hoisted_6, toDisplayString(unref(cellInfoText) ? `${unref(cellInfoText)}` : ""), 1)
          ]),
          createBaseVNode("div", _hoisted_7, [
            createBaseVNode("button", {
              type: "button",
              class: "btn",
              onClick: restartGame
            }, "重新生成"),
            createBaseVNode("button", {
              type: "button",
              class: "btn",
              onClick: reproduceGame
            }, " 重试本局 "),
            createVNode(_component_MinesweeperCheckbox, {
              title: "保证第一次不是雷",
              disabled: unref(gameStatus) === 2 || unref(isReproducedGame),
              modelValue: unref(config).avoidBadStart,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(config).avoidBadStart = $event)
            }, {
              default: withCtx(() => [
                createTextVNode("避免坏开局")
              ]),
              _: 1
            }, 8, ["disabled", "modelValue"]),
            createCommentVNode("", true)
          ])
        ])
      ], 32);
    };
  }
});
const minesweeper_vue_vue_type_style_index_0_scoped_6c66ed0b_lang = "";
const minesweeper = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-6c66ed0b"]]);
export {
  minesweeper as default
};
